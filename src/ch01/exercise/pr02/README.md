## 1.2 编写一个程序求解字谜游戏问题
编写一个程序求解字谜游戏问题

---

书中p1页提到，对于输入是由一些字母构成的一个二维数组以及一组单词组成。
目标是要找出字谜中的单词，这些单词可能是水平、垂直或沿对角线上任何方向放置的。
例如：
|      | 1    | 2    | 3    | 4    |
| ---- | ---- | ---- | ---- | ---- |
| 1    | t    | h    | i    | s    |
| 2    | w    | a    | t    | s    |
| 3    | o    | a    | h    | g    |
| 4    | f    | g    | d    | t    |

字谜由单词this、two、fat、that组成。
this: (1,1) - (1,4)
two: (1,1) - (3,1)
fat: (4,1) - (2,3)
that: (4,4) - (1,1)

书中提到了两种直观的方法来实现这个算法
1. 对单词表中的每个单词，我们检查每一个有序三元组（行，列，方向）检验是否有单词存在。这需要大量的嵌套for循环。
2. 对于每一个尚未越出迷板边缘的有序四元组（行，列，方向，字符数）我们可以测试是否所指的单词在单词表中。
这也导致使用大量嵌套for循环。如果在任意单词中的最大字符数已知，那么该算法有可能节省一些时间。
3. ...


链接：https://www.nowcoder.com/questionTerminal/5d54591ee06247979d0c6b9b4ee9101d
来源：牛客网

a. 利用可扩散列的算法实现字谜程序。（字谜游戏描述：输入一些字母和单词的二维数组组成。目标是要找出字谜中的单词，这些单词可能是水平，垂直或沿对角线以任何方向放置的）
b. 通过存储每一个单词W以及W的所有前缀，我们可以大大加快运行速度（如果w的一个前缀刚好是词典中的一个单词，那么就把它作为实际的单词来储存。）虽然这看起来极大地增加了散列表的大小，但实际上并不是，因为许多单词有相同的前缀。当以某个特定的方向执行一次扫描的时候，如果被查到的单词作为前缀不在散列表中，那么在这个方向上的扫描可以及早终止。利用这种思想编写一个改进的程序来解决字谜游戏问题
c. 如果我们愿意牺牲散列表ADT的严肃性，那么我们可以在（b）部分使程序加速：例如，如果我们刚刚计算出‘excel’的散列函数，那么我们就不必再从头开始计算‘excel’的散列函数。调整散列函数使得它能够利用前面的计算。
d. 把使用前缀的想法结合到对分查找算法中。比较哪个算法那更快？

Trie树